<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="preconnect" href="https://fonts.bunny.net">
  <link href="https://fonts.bunny.net/css?family=anton:400|comic-neue:400,700" rel="stylesheet">
  <!-- Prism.js CSS -->
  <link href="/assets/prismjs/themes/prism.css" rel="stylesheet" />
  <link href="/assets/prismjs/plugins/line-numbers/prism-line-numbers.css" rel="stylesheet" />
  <title>HTML Validator - public.monster</title>
  <style>
    body {
      background: #008080;
      color: #000;
      font-family: "Comic Neue", "Comic Sans MS", cursive;
      margin: 20px;
    }

    main {
      background: #c0c0c0;
      border: 4px outset #fff;
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
      position: relative;
    }

    h1 {
      color: #ff00ff;
      font-family: Anton, Impact, "Arial Black", sans-serif;
      text-shadow: 3px 3px 0 #000, 5px 5px 10px rgba(0,0,0,0.5);
      font-size: 2.5em;
      margin: 0;
      letter-spacing: 1px;
    }

    h2 {
      color: #000;
      background: #ff0;
      padding: 5px 10px;
      display: inline-block;
    }

    .result-section {
      margin: 15px 0;
      padding: 10px;
      border: 2px inset #999;
      background: #fff;
      max-height: 400px;
      overflow-y: auto;
    }

    .error {
      color: #fff;
      background: #d32f2f;
      padding: 10px;
      margin: 5px 0;
      border: 1px solid #b71c1c;
      border-radius: 4px;
    }

    .warning {
      color: #000;
      background: #ffecb3;
      padding: 10px;
      margin: 5px 0;
      border: 1px solid #ffc107;
      border-radius: 4px;
    }

    .success {
      color: #fff;
      background: #388e3c;
      padding: 10px;
      margin: 5px 0;
      border: 1px solid #2e7d32;
      border-radius: 4px;
    }

    a {
      color: #00f;
      text-decoration: underline;
    }

    .loading {
      display: block;
      color: #008000;
      font-weight: bold;
      text-align: center;
      padding: 20px;
    }

    .view-source-btn {
      background: #008000;
      color: white;
      border: none;
      padding: 10px 15px;
      margin: 10px 0;
      cursor: pointer;
      border: 2px outset #fff;
      font-family: "Comic Neue", "Comic Sans MS", cursive;
      font-weight: bold;
    }

    .view-source-btn:hover {
      background: #006400;
    }

    .source-code-container {
      display: none;
      margin-top: 15px;
      border: 2px inset #999;
      background: #fff;
    }

    pre[class*="language-"] {
      border: 1px solid #ccc;
      border-radius: 4px;
      padding: 1em;
      overflow: auto;
      background: #f4f4f4;
    }

    .line-highlight {
      background-color: #ffeb3b7a;
      display: block;
      padding: 2px 0;
      border-radius: 2px;
    }

    .line-link {
      color: #1976d2;
      text-decoration: underline;
      cursor: pointer;
    }

    .line-link:hover {
      color: #0d47a1;
    }
  </style>
</head>
<body>
  <main role="main">
    <h1>üîç HTML Validator</h1>

    <p>Check your HTML code for errors and get suggestions for improvements! This tool helps make your web pages more beginner-friendly.</p>
    
    <div id="loading" class="loading">‚è≥ Loading and validating your HTML...</div>

    <button id="viewSourceBtn" class="view-source-btn">üëÄ View Source</button>

    <div id="sourceCodeContainer" class="source-code-container">
      <h3>HTML Source Code:</h3>
      <div id="sourceCodeContent" class="result-section"></div>
    </div>

    <h2>Validation Results</h2>
    <div id="validationResults" class="result-section">
      <p>Your validation results will appear here.</p>
    </div>

    <p><a href="/">‚Üê Back to Dashboard</a></p>
  </main>

  <script>
    // Function to validate HTML automatically when page loads
    async function validateUserHTML() {
      try {
        // Get the session token
        let token = null;
        try {
          // Attempt to get token via Hanko
          if (window.hanko) {
            token = await window.hanko.getSessionToken();
          } else {
            // Fallback: check if token is available in global scope
            token = window.hankoToken;
          }
        } catch (e) {
          console.log("Hanko not initialized, trying fetch without auth");
        }

        // Check if there's a specific file to validate in the URL
        const urlParams = new URLSearchParams(window.location.search);
        const filePath = urlParams.get('file');

        let apiUrl = '/api/validate-html';
        if (filePath) {
          apiUrl += `?file=${encodeURIComponent(filePath)}`;
        }

        // Fetch and validate the user's HTML content
        const validateRes = await fetch(apiUrl, {
          headers: token ? { 'Authorization': 'Bearer ' + token } : {}
        });

        if (validateRes.ok) {
          const results = await validateRes.json();

          // Also fetch the HTML source code to display
          const sourceRes = await fetch(`/api/files/content/${filePath || 'index.html'}`, {
            headers: token ? { 'Authorization': 'Bearer ' + token } : {}
          });

          if (sourceRes.ok) {
            const sourceCode = await sourceRes.text();
            displaySourceCode(sourceCode);
          } else {
            // Even if source code retrieval fails, still show validation results
            console.error('Failed to fetch source code:', sourceRes.status, await sourceRes.text());
          }

          displayValidationResults(results);
        } else if (validateRes.status === 404) {
          document.getElementById('validationResults').innerHTML =
            '<div class="error">No index.html file found to validate. Please upload an index.html file first.</div>' +
            '<p><a href="/">‚Üê Go to Dashboard to upload files</a></p>';
        } else {
          document.getElementById('validationResults').innerHTML =
            `<div class="error">Could not validate your HTML: ${validateRes.status} ${validateRes.statusText}</div>`;
        }
      } catch (error) {
        console.error('Error validating HTML:', error);
        document.getElementById('validationResults').innerHTML =
          `<div class="error">Error validating HTML: ${error.message}</div>`;
      } finally {
        // Hide loading indicator
        document.getElementById('loading').style.display = 'none';
      }
    }

    // Display the HTML source code with syntax highlighting and line numbers
    function displaySourceCode(sourceCode) {
      const sourceCodeElement = document.getElementById('sourceCodeContent');
      // Encode the HTML to be displayed safely in a pre tag
      const encodedSource = escapeHtml(sourceCode);
      sourceCodeElement.innerHTML = `<pre class="line-numbers"><code class="language-html">${encodedSource}</code></pre>`;

      // If Prism with line numbers plugin is loaded, highlight the newly added code
      if (window.Prism && typeof Prism.highlightElement === 'function') {
        const codeElement = sourceCodeElement.querySelector('code');
        if (codeElement) {
          // The line-numbers plugin should automatically handle line numbering
          // when the element has the 'line-numbers' class
          Prism.highlightElement(codeElement);
        }
      } else {
        // If Prism hasn't loaded yet, wait for it to load and then highlight
        // We'll add a mechanism to highlight once Prism is available
        ensurePrismHighlight(sourceCodeElement.querySelector('code'));
      }
    }

    // Function to ensure code gets highlighted once Prism is loaded
    function ensurePrismHighlight(codeElement) {
      if (!codeElement) return;

      // Check if Prism is available
      if (window.Prism && typeof Prism.highlightElement === 'function') {
        // The pre element containing the code should have line-numbers class for the plugin to work
        const preElement = codeElement.closest('pre');
        if (preElement && !preElement.classList.contains('line-numbers')) {
          preElement.classList.add('line-numbers');
        }
        Prism.highlightElement(codeElement);
      } else {
        // Wait a bit and try again
        setTimeout(() => ensurePrismHighlight(codeElement), 100);
      }
    }

    // Display validation results in a user-friendly format
    function displayValidationResults(results) {
      if (results.valid) {
        document.getElementById('validationResults').innerHTML =
          '<div class="success">‚úÖ Your HTML looks good! No major issues found.</div>' +
          '<div class="success">‚ú® Your page is beginner-friendly! ‚ú®</div>';
      } else {
        let resultHTML = '<h3>Issues Found:</h3><ul>';

        // Group messages by severity
        const errors = results.issues.filter(issue => issue.type.toLowerCase() === 'error');
        const warnings = results.issues.filter(issue => issue.type.toLowerCase() !== 'error');

        // Display errors first
        errors.forEach(issue => {
          // Clean up the confusing bracket representations in the error message and provide more helpful text
          let cleanMessage = issue.message.replace(/\[ \]/g, '');

          // Make some common HTMLHint messages more user-friendly
          if (cleanMessage.includes('Tag must be paired')) {
            cleanMessage = cleanMessage.replace('Tag must be paired, no start tag:', 'Found closing tag with no matching opening tag:')
              .replace('Tag must be paired, missing:', 'Found opening tag with no matching closing tag:');
          }

          resultHTML += `<li class="error"><strong>${issue.type}:</strong> ${cleanMessage} at <a href="#" class="line-link" data-line="${issue.line}">line ${issue.line}</a>, col ${issue.column}<br>`;
          if (issue.codeSnippet) {
            resultHTML += `<code>&lt; &nbsp;${escapeHtml(issue.codeSnippet)}&nbsp; &gt;</code>`;
          }
          resultHTML += '</li>';
        });

        // Then warnings
        warnings.forEach(issue => {
          // Clean up the confusing bracket representations in the warning message and provide more helpful text
          let cleanMessage = issue.message.replace(/\[ \]/g, '');

          // Make some common HTMLHint messages more user-friendly
          if (cleanMessage.includes('Tag must be paired')) {
            cleanMessage = cleanMessage.replace('Tag must be paired, no start tag:', 'Found closing tag with no matching opening tag:')
              .replace('Tag must be paired, missing:', 'Found opening tag with no matching closing tag:');
          }

          resultHTML += `<li class="warning"><strong>${issue.type}:</strong> ${cleanMessage} at <a href="#" class="line-link" data-line="${issue.line}">line ${issue.line}</a>, col ${issue.column}<br>`;
          if (issue.codeSnippet) {
            resultHTML += `<code>&lt; &nbsp;${escapeHtml(issue.codeSnippet)}&nbsp; &gt;</code>`;
          }
          resultHTML += '</li>';
        });

        resultHTML += '</ul>';

        // Add a summary at the top
        const errorCount = errors.length;
        const warningCount = warnings.length;
        const totalCount = results.issues.length;

        resultHTML = `<div class="error">Found ${totalCount} issue${totalCount !== 1 ? 's' : ''} (${errorCount} error${errorCount !== 1 ? 's' : ''}, ${warningCount} warning${warningCount !== 1 ? 's' : ''})</div>` + resultHTML;

        // Add a tip about HTML structure for beginners
        if (errors.length > 0 || warnings.length > 0) {
          resultHTML += '<div class="warning"><h3>üí° HTML Tips for Beginners:</h3>' +
            '<ul>' +
            '<li>HTML tags must be properly closed (e.g., &lt;p&gt;Content&lt;/p&gt;)</li>' +
            '<li>Always include alt attributes for images: &lt;img src="image.jpg" alt="Description"&gt;</li>' +
            '<li>Use double quotes for attribute values: &lt;a href="page.html"&gt;</li>' +
            '<li>HTML tag names should be lowercase: &lt;p&gt; not &lt;P&gt;</li>' +
            '</ul></div>';
        }

        document.getElementById('validationResults').innerHTML = resultHTML;

        // Set up event listeners for line links in validation results
        setupLineLinkListeners();
      }
    }

    // Function to highlight a specific line in the source code view
    function highlightLine(lineNumber) {
      const sourceCodeElement = document.getElementById('sourceCodeContent');
      if (!sourceCodeElement) return;

      // Make sure the source code section is visible
      const container = document.getElementById('sourceCodeContainer');
      if (container.style.display === 'none' || container.style.display === '') {
        container.style.display = 'block';
        const viewSourceBtn = document.getElementById('viewSourceBtn');
        if (viewSourceBtn) {
          viewSourceBtn.textContent = '-hide Source';
        }
      }

      // Find the line number element
      // Prism's line-numbers plugin adds line numbers as a pseudo-element,
      // so we need to scroll to the appropriate line
      const preElement = sourceCodeElement.querySelector('pre');
      if (!preElement) return;

      // Split the content by newlines to identify the target line
      const codeElement = preElement.querySelector('code');
      if (!codeElement) return;

      // Get all the text content and split by lines
      const lines = codeElement.textContent.split('\n');
      if (lineNumber > 0 && lineNumber <= lines.length) {
        // Get all the line number elements created by the line-numbers plugin
        // Since Prism creates these dynamically, we'll add a temporary highlight
        const lineIndex = lineNumber - 1; // Convert to 0-based index

        // Create an array of all lines with line numbers
        const allLines = lines.map((line, index) => {
          if (index === lineIndex) {
            // Highlight this line
            return `<span class="line-highlight">${line}</span>`;
          }
          return line;
        });

        // Temporarily update the content to show the highlight
        const originalHTML = codeElement.innerHTML;
        codeElement.innerHTML = allLines.join('\n');

        // Scroll to the highlighted line
        const highlightedLine = codeElement.querySelector('.line-highlight');
        if (highlightedLine) {
          highlightedLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Remove highlight after a few seconds
          setTimeout(() => {
            codeElement.innerHTML = originalHTML;
          }, 3000);
        }
      }
    }

    // Set up event listeners for line links in validation results
    function setupLineLinkListeners() {
      // Use event delegation to handle clicks on line links
      const validationResults = document.getElementById('validationResults');
      if (!validationResults) return;

      // Remove any existing listeners to avoid duplicates
      validationResults.replaceWith(validationResults.cloneNode(true));
      const newValidationResults = document.getElementById('validationResults');

      newValidationResults.addEventListener('click', function(e) {
        if (e.target.classList.contains('line-link')) {
          e.preventDefault();
          const lineNumber = parseInt(e.target.getAttribute('data-line'));
          if (!isNaN(lineNumber)) {
            highlightLine(lineNumber);
          }
        }
      });
    }

    // Helper function to escape HTML for display
    function escapeHtml(unsafe) {
      return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    // Initialize by validating the user's HTML on page load
    window.addEventListener('DOMContentLoaded', (event) => {
      // Set up view source button event listener
      document.getElementById('viewSourceBtn').addEventListener('click', function() {
        const container = document.getElementById('sourceCodeContainer');
        if (container.style.display === 'none' || container.style.display === '') {
          container.style.display = 'block';
          this.textContent = '-hide Source';
        } else {
          container.style.display = 'none';
          this.textContent = 'üëÄ View Source';
        }
      });

      validateUserHTML();
    });

    // Load Prism.js and the line numbers plugin after the DOM has loaded
    document.addEventListener('DOMContentLoaded', function() {
      // First, load the main Prism.js script
      const script = document.createElement('script');
      script.src = '/assets/prismjs/prism.js';
      document.head.appendChild(script);

      // Wait for the main Prism script to load, then load the plugin
      script.onload = function() {
        // Load the line numbers plugin after Prism is loaded
        const lineNumbersScript = document.createElement('script');
        lineNumbersScript.src = '/assets/prismjs/plugins/line-numbers/prism-line-numbers.min.js';
        lineNumbersScript.onload = function() {
          // Optional: Re-highlight code if it's already in the DOM
          if (window.Prism) {
            Prism.highlightAll();
          }
        };
        document.head.appendChild(lineNumbersScript);
      };
    });
  </script>
</body>
</html>