<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="preconnect" href="https://fonts.bunny.net">
<link href="https://fonts.bunny.net/css?family=anton:400|comic-neue:400,700" rel="stylesheet">
<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üåê</text></svg>">
<title>File Manager - public.monster</title>
<!-- Privacy-friendly analytics by Plausible -->
<script async src="https://plausible.io/js/pa-neokOJSyQG1cGL1NXRHGs.js"></script>
<script>
  window.plausible=window.plausible||function(){(plausible.q=plausible.q||[]).push(arguments)},plausible.init=plausible.init||function(i){plausible.o=i||{}};
  plausible.init()
</script>
<script type="module">
import { register } from "https://esm.run/@teamhanko/hanko-elements";

const { hanko } = await register("HANKO_API_URL_PLACEHOLDER");

let username = null;

// Listen for session changes and reload page
hanko.onSessionCreated(() => {
  window.location.reload();
});

hanko.onSessionExpired(() => {
  window.location.href = '/';
});

hanko.onUserDeleted(() => {
  window.location.href = '/';
});

const token = await hanko.getSessionToken();
if (!token) {
  window.location.href = '/';
} else {
  const user = await hanko.getUser();
  username = user.username;
  document.getElementById('username').textContent = username;
  loadFiles(token);
}

async function loadFiles(token) {
  const res = await fetch('/api/files', {
    headers: { Authorization: `Bearer ${token}` }
  });
  
  if (!res.ok) {
    document.getElementById('tree').textContent = 'Failed to load files';
    return;
  }
  
  const files = await res.json();
  renderTree(files, token);
}

function formatSize(bytes) {
  if (bytes === 0) return '[0B]';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return '[' + (bytes / Math.pow(k, i)).toFixed(i === 0 ? 0 : 1) + sizes[i] + ']';
}

function buildTree(files) {
  const tree = {};
  
  // Filter out directory entries, we'll infer them from file paths
  const fileEntries = files.filter(f => !f.IsDirectory);
  
  fileEntries.forEach(file => {
    const parts = file.ObjectName.split('/').filter(p => p);
    let current = tree;
    
    parts.forEach((part, idx) => {
      if (idx === parts.length - 1) {
        // This is the file itself
        current[part] = {
          type: 'file',
          size: file.Length,
          path: file.ObjectName
        };
      } else {
        // This is a directory in the path
        if (!current[part]) {
          current[part] = { type: 'dir', children: {} };
        }
        current = current[part].children;
      }
    });
  });
  
  return tree;
}

function renderNode(name, node, prefix, isLast, token) {
  const lines = [];
  const connector = isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
  const extension = isLast ? '    ' : '‚îÇ   ';
  
  if (node.type === 'file') {
    const line = document.createElement('div');
    line.style.fontFamily = 'monospace';
    line.style.lineHeight = '1.4';
    
    const prefixSpan = document.createElement('span');
    prefixSpan.textContent = prefix + connector;
    
    const link = document.createElement('a');
    link.href = `/~${username}/${node.path}`;
    link.download = name;
    link.textContent = name;
    link.style.color = '#00f';
    
    const size = document.createElement('span');
    size.textContent = ' ' + formatSize(node.size);
    size.style.color = '#666';
    
    const deleteBtn = document.createElement('span');
    deleteBtn.textContent = ' üóëÔ∏è';
    deleteBtn.style.cursor = 'pointer';
    deleteBtn.style.fontSize = '0.9em';
    deleteBtn.onclick = () => deleteFile(node.path, token);
    
    line.appendChild(prefixSpan);
    line.appendChild(link);
    line.appendChild(size);
    line.appendChild(deleteBtn);
    lines.push(line);
  } else {
    const line = document.createElement('div');
    line.style.fontFamily = 'monospace';
    line.style.lineHeight = '1.4';
    
    const prefixSpan = document.createElement('span');
    prefixSpan.textContent = prefix + connector + 'üìÇ ' + name + '/';
    
    const deleteBtn = document.createElement('span');
    deleteBtn.textContent = ' üóëÔ∏è';
    deleteBtn.style.cursor = 'pointer';
    deleteBtn.style.fontSize = '0.9em';
    deleteBtn.onclick = () => deleteDirectory(name, node, token);
    
    line.appendChild(prefixSpan);
    line.appendChild(deleteBtn);
    line.style.color = '#000';
    lines.push(line);
    
    const children = Object.entries(node.children).sort((a, b) => {
      if (a[1].type === 'dir' && b[1].type !== 'dir') return -1;
      if (a[1].type !== 'dir' && b[1].type === 'dir') return 1;
      return a[0].localeCompare(b[0]);
    });
    children.forEach(([childName, childNode], idx) => {
      const childIsLast = idx === children.length - 1;
      const childLines = renderNode(childName, childNode, prefix + extension, childIsLast, token);
      lines.push(...childLines);
    });
  }
  
  return lines;
}

function renderTree(files, token) {
  const treeEl = document.getElementById('tree');
  treeEl.innerHTML = '';
  
  if (files.length === 0) {
    treeEl.textContent = 'No files uploaded yet. Go to the upload page to add files!';
    return;
  }
  
  const tree = buildTree(files);
  const pre = document.createElement('pre');
  
  const header = document.createElement('div');
  header.style.fontFamily = 'monospace';
  
  const headerText = document.createElement('span');
  headerText.textContent = `~${username}/`;
  
  const deleteAllBtn = document.createElement('span');
  deleteAllBtn.textContent = ' üóëÔ∏è';
  deleteAllBtn.style.cursor = 'pointer';
  deleteAllBtn.title = 'Delete everything (cannot be undone!)';
  deleteAllBtn.onclick = () => deleteEverything(files, token);
  
  const downloadBtn = document.createElement('span');
  downloadBtn.textContent = ' üì•';
  downloadBtn.style.cursor = 'pointer';
  downloadBtn.title = 'Download all files as zip';
  downloadBtn.onclick = () => downloadAllAsZip(files, token);
  
  header.appendChild(headerText);
  header.appendChild(deleteAllBtn);
  header.appendChild(downloadBtn);
  pre.appendChild(header);
  
  const entries = Object.entries(tree).sort((a, b) => {
    if (a[1].type === 'dir' && b[1].type !== 'dir') return -1;
    if (a[1].type !== 'dir' && b[1].type === 'dir') return 1;
    return a[0].localeCompare(b[0]);
  });
  entries.forEach(([name, node], idx) => {
    const isLast = idx === entries.length - 1;
    const lines = renderNode(name, node, '', isLast, token);
    lines.forEach(line => pre.appendChild(line));
  });
  
  treeEl.appendChild(pre);
}

async function downloadAllAsZip(files, token) {
  const link = document.createElement('a');
  link.href = '/api/download-zip';
  link.download = `${username}.zip`;
  
  // Add auth token as we can't set headers on <a> download
  const res = await fetch('/api/download-zip', {
    headers: { 'Authorization': `Bearer ${token}` }
  });
  
  if (res.ok) {
    const blob = await res.blob();
    const url = URL.createObjectURL(blob);
    link.href = url;
    link.click();
    URL.revokeObjectURL(url);
  } else {
    alert('Failed to download zip');
  }
}

async function deleteEverything(files, token) {
  const userInput = prompt('Type "EVERYTHING" in all caps to confirm deletion of ALL files.\n\nWARNING: This cannot be undone!');
  if (userInput !== 'EVERYTHING') {
    if (userInput !== null) alert('Confirmation text does not match. Deletion cancelled.');
    return;
  }
  
  // Collect all file paths
  const filesToDelete = files.map(f => f.ObjectName);
  
  // Create progress indicator
  const progressDiv = document.createElement('div');
  progressDiv.style.position = 'fixed';
  progressDiv.style.top = '50%';
  progressDiv.style.left = '50%';
  progressDiv.style.transform = 'translate(-50%, -50%)';
  progressDiv.style.background = '#c0c0c0';
  progressDiv.style.border = '4px outset #fff';
  progressDiv.style.padding = '20px';
  progressDiv.style.zIndex = '10000';
  progressDiv.style.minWidth = '300px';
  progressDiv.textContent = `Deleting 0 of ${filesToDelete.length} files...`;
  document.body.appendChild(progressDiv);
  
  // Delete all files
  for (let i = 0; i < filesToDelete.length; i++) {
    const path = filesToDelete[i];
    progressDiv.textContent = `Deleting ${i + 1} of ${filesToDelete.length} files...`;
    
    const res = await fetch('/api/files', {
      method: 'DELETE',
      headers: { 
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ path })
    });
    
    if (!res.ok) {
      document.body.removeChild(progressDiv);
      alert(`Failed to delete ${path}`);
      return;
    }
  }
  
  document.body.removeChild(progressDiv);
  loadFiles(token);
}

async function deleteDirectory(name, node, token) {
  const userInput = prompt(`Type the directory name "${name}" to confirm deletion:`);
  if (userInput !== name) {
    if (userInput !== null) alert('Directory name does not match. Deletion cancelled.');
    return;
  }
  
  // Collect all file paths in this directory
  const filesToDelete = [];
  function collectFiles(n) {
    if (n.type === 'file') {
      filesToDelete.push(n.path);
    } else {
      Object.values(n.children).forEach(collectFiles);
    }
  }
  collectFiles(node);
  
  // Create progress indicator
  const progressDiv = document.createElement('div');
  progressDiv.style.position = 'fixed';
  progressDiv.style.top = '50%';
  progressDiv.style.left = '50%';
  progressDiv.style.transform = 'translate(-50%, -50%)';
  progressDiv.style.background = '#c0c0c0';
  progressDiv.style.border = '4px outset #fff';
  progressDiv.style.padding = '20px';
  progressDiv.style.zIndex = '10000';
  progressDiv.style.minWidth = '300px';
  progressDiv.textContent = `Deleting 0 of ${filesToDelete.length} files...`;
  document.body.appendChild(progressDiv);
  
  // Delete all files
  for (let i = 0; i < filesToDelete.length; i++) {
    const path = filesToDelete[i];
    progressDiv.textContent = `Deleting ${i + 1} of ${filesToDelete.length} files...`;
    
    const res = await fetch('/api/files', {
      method: 'DELETE',
      headers: { 
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ path })
    });
    
    if (!res.ok) {
      document.body.removeChild(progressDiv);
      alert(`Failed to delete ${path}`);
      return;
    }
  }
  
  document.body.removeChild(progressDiv);
  loadFiles(token);
}

async function deleteFile(path, token) {
  if (!confirm(`Delete ${path}?`)) return;
  
  const res = await fetch('/api/files', {
    method: 'DELETE',
    headers: { 
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ path })
  });
  
  if (res.ok) {
    loadFiles(token);
  } else {
    alert('Delete failed');
  }
}
</script>
<style>
body{background:#008080;color:#000;font-family:"Comic Neue","Comic Sans MS",cursive;margin:20px}
main{background:#c0c0c0;border:4px outset #fff;padding:20px;max-width:800px;margin:0 auto;position:relative}
h1{color:#ff00ff;font-family:Anton,Impact,"Arial Black",sans-serif;text-shadow:3px 3px 0 #000,5px 5px 10px rgba(0,0,0,0.5);font-size:2.5em;margin:0;letter-spacing:1px}
h2{color:#000;background:#ff0;padding:5px 10px;display:inline-block}
a{color:#00f;text-decoration:underline}
button{background:#c0c0c0;border:2px outset #fff;padding:5px 15px;cursor:pointer;font-family:inherit;font-size:1em;margin:5px}
button:active{border-style:inset}
#tree{background:#fff;border:2px inset #999;padding:15px;margin:20px 0;max-height:500px;overflow-y:scroll;font-family:monospace}
#tree::-webkit-scrollbar{width:16px}
#tree::-webkit-scrollbar-track{background:#c0c0c0;border:2px inset #999}
#tree::-webkit-scrollbar-thumb{background:#808080;border:2px outset #999}
#tree::-webkit-scrollbar-thumb:hover{background:#606060}
pre{margin:0;font-family:monospace}
.beta-badge{position:absolute;top:-10px;right:-10px;background:#ff0;color:#f00;font-weight:bold;font-size:1.5em;padding:8px 16px;border:3px solid #f00;transform:rotate(15deg);box-shadow:3px 3px 0 #000;z-index:1000}
@media(max-width:600px){h1{font-size:1.5em}h2{font-size:1.2em}.beta-badge{font-size:1.2em;padding:6px 12px}}
</style>
</head>
<body>
<main role="main">
<div class="beta-badge">BETA</div>
<h1>üåê File Manager üåê</h1>
<h2>~<span id="username"></span></h2>
<div id="tree">Loading...</div>
<p><a href="/">‚Üê Back to Upload</a></p>
<footer style="text-align:center;margin-top:40px;padding-top:20px;border-top:2px groove #999;font-size:0.9em">
by <a href="/~dmytri" rel="noopener">~dmytri</a> &nbsp;|&nbsp; <a href="/about">about</a> &nbsp;|&nbsp; <a href="/faq">faq</a>
</footer>
</main>
</body>
</html>
